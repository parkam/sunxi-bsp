diff --git a/include/config_distro_defaults.h b/include/config_distro_defaults.h
index 5d18a4b..7532f22 100644
--- a/include/config_distro_defaults.h
+++ b/include/config_distro_defaults.h
@@ -45,7 +45,7 @@
 
 #define CONFIG_CMDLINE_EDITING
 #define CONFIG_AUTO_COMPLETE
-#define CONFIG_BOOTDELAY     2
+#define CONFIG_BOOTDELAY     0
 #define CONFIG_SYS_LONGHELP
 #define CONFIG_MENU
 #define CONFIG_DOS_PARTITION
diff --git a/include/configs/sunxi-common.h b/include/configs/sunxi-common.h
index 019a1bb..5d674a1 100644
--- a/include/configs/sunxi-common.h
+++ b/include/configs/sunxi-common.h
@@ -137,6 +137,8 @@
 #define RUN_BOOT_RAM	""
 #endif
 
+
+
 #define CONFIG_BOOTCOMMAND \
 	RUN_BOOT_RAM \
 	"if run loadbootenv; then " \
@@ -166,6 +168,7 @@
 	"panicarg=panic=10\0" \
 	"extraargs=\0" \
 	"loglevel=8\0" \
+	"bootdelay=0\0" \
 	"scriptaddr=0x44000000\0" \
 	"device=mmc\0" \
 	"partition=0:1\0" \
@@ -185,26 +188,26 @@
 	"bootscr=boot.scr\0" \
 	"script=script.bin\0" \
 	"loadbootscr=" \
-	  "fatload $device $partition $scriptaddr ${bootscr}" \
+	  "ext2load $device $partition $scriptaddr ${bootscr}" \
 	  " || " \
 	  "ext2load $device $partition $scriptaddr boot/${bootscr}" \
 	  " ||" \
-	  "ext2load $device $partition $scriptaddr ${bootscr}" \
+	  "fatload $device $partition $scriptaddr ${bootscr}" \
 	  "\0" \
 	"loadbootenv=" \
-	  "fatload $device $partition $scriptaddr ${bootenv}" \
+	  "ext2load $device $partition $scriptaddr ${bootenv}" \
 	  " || " \
 	  "ext2load $device $partition $scriptaddr boot/${bootenv}" \
 	  " || " \
-	  "ext2load $device $partition $scriptaddr ${bootenv}" \
+	  "fatload $device $partition $scriptaddr ${bootenv}" \
 	  "\0" \
 	"loadkernel=" \
 	  "if "\
 	    "bootpath=/boot/" \
 	    " && " \
-	    "ext2load $device $partition 0x43000000 ${bootpath}${script}" \
+	    "ext3load $device $partition 0x43000000 ${bootpath}${script}" \
 	    " && " \
-	    "ext2load $device $partition 0x48000000 ${bootpath}${kernel}" \
+	    "ext3load $device $partition 0x48000000 ${bootpath}${kernel}" \
 	  ";then true; elif " \
 	    "bootpath=/" \
 	    " && " \
@@ -423,5 +426,8 @@
 #ifndef CONFIG_SPL_BUILD
 #include <config_distro_defaults.h>
 #endif
-
+#ifdef CONFIG_BOOTDELAY
+#undef CONFIG_BOOTDELAY
+#define CONFIG_BOOTDELAY 0
+#endif 
 #endif /* _SUNXI_COMMON_CONFIG_H */
diff --git a/tools/buildman/buildman b/tools/buildman/buildman
deleted file mode 120000
index e4fba2d..0000000
--- a/tools/buildman/buildman
+++ /dev/null
@@ -1 +0,0 @@
-buildman.py
\ No newline at end of file
diff --git a/tools/buildman/buildman b/tools/buildman/buildman
new file mode 100755
index 0000000..8822efe
--- /dev/null
+++ b/tools/buildman/buildman
@@ -0,0 +1,123 @@
+#!/usr/bin/env python
+#
+# Copyright (c) 2012 The Chromium OS Authors.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+"""See README for more information"""
+
+import multiprocessing
+from optparse import OptionParser
+import os
+import re
+import sys
+import unittest
+
+# Bring in the patman libraries
+our_path = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(our_path, '../patman'))
+
+# Our modules
+import board
+import builder
+import checkpatch
+import command
+import control
+import doctest
+import gitutil
+import patchstream
+import terminal
+import toolchain
+
+def RunTests():
+    import test
+    import doctest
+
+    result = unittest.TestResult()
+    for module in ['toolchain']:
+        suite = doctest.DocTestSuite(module)
+        suite.run(result)
+
+    # TODO: Surely we can just 'print' result?
+    print result
+    for test, err in result.errors:
+        print err
+    for test, err in result.failures:
+        print err
+
+    sys.argv = [sys.argv[0]]
+    suite = unittest.TestLoader().loadTestsFromTestCase(test.TestBuild)
+    result = unittest.TestResult()
+    suite.run(result)
+
+    # TODO: Surely we can just 'print' result?
+    print result
+    for test, err in result.errors:
+        print err
+    for test, err in result.failures:
+        print err
+
+
+parser = OptionParser()
+parser.add_option('-b', '--branch', type='string',
+       help='Branch name to build')
+parser.add_option('-B', '--bloat', dest='show_bloat',
+       action='store_true', default=False,
+       help='Show changes in function code size for each board')
+parser.add_option('-c', '--count', dest='count', type='int',
+       default=-1, help='Run build on the top n commits')
+parser.add_option('-e', '--show_errors', action='store_true',
+       default=False, help='Show errors and warnings')
+parser.add_option('-f', '--force-build', dest='force_build',
+       action='store_true', default=False,
+       help='Force build of boards even if already built')
+parser.add_option('-d', '--detail', dest='show_detail',
+       action='store_true', default=False,
+       help='Show detailed information for each board in summary')
+parser.add_option('-g', '--git', type='string',
+       help='Git repo containing branch to build', default='.')
+parser.add_option('-H', '--full-help', action='store_true', dest='full_help',
+       default=False, help='Display the README file')
+parser.add_option('-j', '--jobs', dest='jobs', type='int',
+       default=None, help='Number of jobs to run at once (passed to make)')
+parser.add_option('-k', '--keep-outputs', action='store_true',
+       default=False, help='Keep all build output files (e.g. binaries)')
+parser.add_option('--list-tool-chains', action='store_true', default=False,
+       help='List available tool chains')
+parser.add_option('-n', '--dry-run', action='store_true', dest='dry_run',
+       default=False, help="Do a try run (describe actions, but no nothing)")
+parser.add_option('-Q', '--quick', action='store_true',
+       default=False, help='Do a rough build, with limited warning resolution')
+parser.add_option('-s', '--summary', action='store_true',
+       default=False, help='Show a build summary')
+parser.add_option('-S', '--show-sizes', action='store_true',
+       default=False, help='Show image size variation in summary')
+parser.add_option('--step', type='int',
+       default=1, help='Only build every n commits (0=just first and last)')
+parser.add_option('-t', '--test', action='store_true', dest='test',
+                  default=False, help='run tests')
+parser.add_option('-T', '--threads', type='int',
+       default=None, help='Number of builder threads to use')
+parser.add_option('-u', '--show_unknown', action='store_true',
+       default=False, help='Show boards with unknown build result')
+
+parser.usage = """buildman -b <branch> [options]
+
+Build U-Boot for all commits in a branch. Use -n to do a dry run"""
+
+(options, args) = parser.parse_args()
+
+# Run our meagre tests
+if options.test:
+    RunTests()
+elif options.full_help:
+    pager = os.getenv('PAGER')
+    if not pager:
+        pager = 'more'
+    fname = os.path.join(os.path.dirname(sys.argv[0]), 'README')
+    command.Run(pager, fname)
+
+# Build selected commits for selected boards
+else:
+    control.DoBuildman(options, args)
diff --git a/tools/patman/patman b/tools/patman/patman
deleted file mode 120000
index 6cc3d7a..0000000
--- a/tools/patman/patman
+++ /dev/null
@@ -1 +0,0 @@
-patman.py
\ No newline at end of file
diff --git a/tools/patman/patman b/tools/patman/patman
new file mode 100755
index 0000000..c60aa5a
--- /dev/null
+++ b/tools/patman/patman
@@ -0,0 +1,166 @@
+#!/usr/bin/env python
+#
+# Copyright (c) 2011 The Chromium OS Authors.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+"""See README for more information"""
+
+from optparse import OptionParser
+import os
+import re
+import sys
+import unittest
+
+# Our modules
+import checkpatch
+import command
+import gitutil
+import patchstream
+import project
+import settings
+import terminal
+import test
+
+
+parser = OptionParser()
+parser.add_option('-a', '--no-apply', action='store_false',
+                  dest='apply_patches', default=True,
+                  help="Don't test-apply patches with git am")
+parser.add_option('-H', '--full-help', action='store_true', dest='full_help',
+       default=False, help='Display the README file')
+parser.add_option('-c', '--count', dest='count', type='int',
+       default=-1, help='Automatically create patches from top n commits')
+parser.add_option('-i', '--ignore-errors', action='store_true',
+       dest='ignore_errors', default=False,
+       help='Send patches email even if patch errors are found')
+parser.add_option('-n', '--dry-run', action='store_true', dest='dry_run',
+       default=False, help="Do a dry run (create but don't email patches)")
+parser.add_option('-p', '--project', default=project.DetectProject(),
+                  help="Project name; affects default option values and "
+                  "aliases [default: %default]")
+parser.add_option('-r', '--in-reply-to', type='string', action='store',
+                  help="Message ID that this series is in reply to")
+parser.add_option('-s', '--start', dest='start', type='int',
+       default=0, help='Commit to start creating patches from (0 = HEAD)')
+parser.add_option('-t', '--ignore-bad-tags', action='store_true',
+                  default=False, help='Ignore bad tags / aliases')
+parser.add_option('--test', action='store_true', dest='test',
+                  default=False, help='run tests')
+parser.add_option('-v', '--verbose', action='store_true', dest='verbose',
+       default=False, help='Verbose output of errors and warnings')
+parser.add_option('--cc-cmd', dest='cc_cmd', type='string', action='store',
+       default=None, help='Output cc list for patch file (used by git)')
+parser.add_option('--no-check', action='store_false', dest='check_patch',
+                  default=True,
+                  help="Don't check for patch compliance")
+parser.add_option('--no-tags', action='store_false', dest='process_tags',
+                  default=True, help="Don't process subject tags as aliaes")
+
+parser.usage = """patman [options]
+
+Create patches from commits in a branch, check them and email them as
+specified by tags you place in the commits. Use -n to do a dry run first."""
+
+
+# Parse options twice: first to get the project and second to handle
+# defaults properly (which depends on project).
+(options, args) = parser.parse_args()
+settings.Setup(parser, options.project, '')
+(options, args) = parser.parse_args()
+
+# Run our meagre tests
+if options.test:
+    import doctest
+
+    sys.argv = [sys.argv[0]]
+    suite = unittest.TestLoader().loadTestsFromTestCase(test.TestPatch)
+    result = unittest.TestResult()
+    suite.run(result)
+
+    for module in ['gitutil', 'settings']:
+        suite = doctest.DocTestSuite(module)
+        suite.run(result)
+
+    # TODO: Surely we can just 'print' result?
+    print result
+    for test, err in result.errors:
+        print err
+    for test, err in result.failures:
+        print err
+
+# Called from git with a patch filename as argument
+# Printout a list of additional CC recipients for this patch
+elif options.cc_cmd:
+    fd = open(options.cc_cmd, 'r')
+    re_line = re.compile('(\S*) (.*)')
+    for line in fd.readlines():
+        match = re_line.match(line)
+        if match and match.group(1) == args[0]:
+            for cc in match.group(2).split(', '):
+                cc = cc.strip()
+                if cc:
+                    print cc
+    fd.close()
+
+elif options.full_help:
+    pager = os.getenv('PAGER')
+    if not pager:
+        pager = 'more'
+    fname = os.path.join(os.path.dirname(sys.argv[0]), 'README')
+    command.Run(pager, fname)
+
+# Process commits, produce patches files, check them, email them
+else:
+    gitutil.Setup()
+
+    if options.count == -1:
+        # Work out how many patches to send if we can
+        options.count = gitutil.CountCommitsToBranch() - options.start
+
+    col = terminal.Color()
+    if not options.count:
+        str = 'No commits found to process - please use -c flag'
+        print col.Color(col.RED, str)
+        sys.exit(1)
+
+    # Read the metadata from the commits
+    if options.count:
+        series = patchstream.GetMetaData(options.start, options.count)
+        cover_fname, args = gitutil.CreatePatches(options.start, options.count,
+                series)
+
+    # Fix up the patch files to our liking, and insert the cover letter
+    series = patchstream.FixPatches(series, args)
+    if series and cover_fname and series.get('cover'):
+        patchstream.InsertCoverLetter(cover_fname, series, options.count)
+
+    # Do a few checks on the series
+    series.DoChecks()
+
+    # Check the patches, and run them through 'git am' just to be sure
+    if options.check_patch:
+        ok = checkpatch.CheckPatches(options.verbose, args)
+    else:
+        ok = True
+    if options.apply_patches:
+        if not gitutil.ApplyPatches(options.verbose, args,
+                                    options.count + options.start):
+            ok = False
+
+    cc_file = series.MakeCcFile(options.process_tags, cover_fname,
+                                not options.ignore_bad_tags)
+
+    # Email the patches out (giving the user time to check / cancel)
+    cmd = ''
+    if ok or options.ignore_errors:
+        cmd = gitutil.EmailPatches(series, cover_fname, args,
+                options.dry_run, not options.ignore_bad_tags, cc_file,
+                in_reply_to=options.in_reply_to)
+
+    # For a dry run, just show our actions as a sanity check
+    if options.dry_run:
+        series.ShowActions(args, cmd, options.process_tags)
+
+    os.remove(cc_file)
